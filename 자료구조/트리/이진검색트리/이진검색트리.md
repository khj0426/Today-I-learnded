### 이진 검색 트리 (Binary Search Tree)

- 이진 검색트리는 이진 트리인데 , 다음의 2가지 조건을 만족하는 트리입니다.

  1. 왼쪽 자식이 있다면 , 왼쪽 자식의 key보다 자기의 key값이 커야합니다.
  2. 오른쪽 자식이 있다면, 오른쪽 자식의 key보다 자기의 key값이 작아야 합니다.

![BST](https://mblogthumb-phinf.pstatic.net/20160816_30/kks227_1471358328556hYfs3_PNG/bst.png?type=w2)

- 위의 그림은 BST를 만족하는 그림입니다.
- 중위 순회(왼쪽->루트->오른쪽)을 하면 key의 값이 `절대 감소하지 않습니다`

#### 이진 검색 트리의 탐색

- 일단 `루트`를 보고, 찾으려는 값이 `k`일떄,

  1. `루트 == K`이면 잘 찾은 거고,
  2. `루트 > K `이면, 왼쪽 서브트리를, 찾아가면 되고
  3. `루트 < K`이면 오른쪽 서브트리를 찾아가면 됩니다.

#### 이진 검색 트리의 삽입

- 탐색과 굉장히 유사합니다. 어디에 삽입해야 BST를 유지할 수 있는지 찾아야 합니다

![BSTinsert](https://mblogthumb-phinf.pstatic.net/20160817_285/kks227_14713626840677JUWd_JPEG/tree5.jpg?type=w2)

- 먼저 루트에서 시작합니다. 이때 삽입하려는 `key값 K`가 있을 떄, 2가지 경우가 존
  재합니다.(중복없는 key)

1. 현재 루트가 key값 K보다 작은 경우
2. 현재 루트가 key값 K보다 큰 경우

- 위의 그림을 토대로 설명해보자면,처음에 루트가 없으므로 31을 집어넣고 31이 루트
  가 되고 끝납니다(예외처리)

- 그 후,16을 넣으려고 합니다. key값 16가 루트인 31보다 작으므로,
  `루트의 key(31)보다 왼쪽 자식의 key(16)가 작아야한다`에 의해서 16을 31의 왼쪽
  자식에 추가합니다.

- 그 후 , 45를 넣어야 합니다. key값 45는 루트 31보다 크므로,
  `루트의 key(31)보다 오른쪽 자식의 key(45)가 커야한다`에 의해 오른쪽 자식을 봅
  니다. 오른쪽 자식이 없으므로, 45를 루트(31)의 오른쪽 자식에 추가합니다.

- 이제 24를 넣어야 합니다. key값 24는 루트 31보다 작으므로, 왼쪽 서브트리를 찾습
  니다. 왼쪽 서브트리에 16이 있는데, key값 24는 16보다 크기 떄문에, 16의 오른쪽
  에 집어넣습니다.

- 다음 7은 31보다 작고, 16보다 작으므로, 16의 왼쪽에 집어넣고, 19는 16보다 크고,
  24보다 작기 떄문에 24의 왼쪽에 집어넣습니다.

- 이런 방식으로 이진 검색 트리의 삽입이 이루어집니다.

#### 이진 검색 트리의 삭제

- 이진 검색 트리의 삭제는 꽤 어렵습니다..
- 먼저 `key가 K`인 노드를 삭제하려면, `key가 K`인 노드를 먼저 찾아야 합니다. 요
  기까진 걍 탐색입니다.

#### 그러나, 노드를 지워도 그 형태가 이진 검색 트리(BST)를 유지해야 합니다.

- 이때 지워야 할 노드에 대해 , 다양한 케이스가 존재합니다.

1. 지워야 할 노드가 `리프`인 경우

- 이건 노드가 리프이므로, 지워도 아무영향이 없습니다. 바로 지워줍니다.

![BSTERASE](https://mblogthumb-phinf.pstatic.net/20160817_94/kks227_14713640895294wDKS_PNG/1.png?type=w2)

![BSTERASE](https://mblogthumb-phinf.pstatic.net/20160817_206/kks227_1471364089770usLFR_PNG/2.png?type=w2)

2. 지워야 할 노드가 `자식이 하나 존재할떄`의 경우

- 자식이 하나의 의미는, 왼쪽 서브트리, 오른쪽 서브트리 중 `하나만 존재`함을 나타
  냅니다. 이 떄는, `자신`을 지우고, `자신의 부모`와 `자신의 자식`을 이어주면 됩
  니다.

![BSTERASE](https://mblogthumb-phinf.pstatic.net/20160817_263/kks227_1471364089946wrbgu_PNG/3.png?type=w2)
![BSTERASE](https://mblogthumb-phinf.pstatic.net/20160817_78/kks227_1471364090140yywaA_PNG/4.png?type=w2)

- 7을 지우고자 할떄, 7의 부모인 6을 7의 자식인 8과 연결합니다 (ERASE 7),
  (CONNECT 6 and 8)

3. 지워야 할 노드가 `자식이 두 개 존재하는` 경우

![ERASEBST](https://mblogthumb-phinf.pstatic.net/20160817_225/kks227_1471364090289UC3u4_PNG/5.png?type=w2)

- 자식이 둘이다라는 의미는 , `왼쪽 서브트리`와 `오른쪽 서브트리` 둘 다 존재함을
  나타냅니다.

- `2`를 지우고자 할 떄, 가능한 선택지가 2개 존재합니다

1. 2보다 작으면서 가장 근접한 key인 노드 1을 노드2를 지우고, 그 자리에 넣습니다.
2. 2보다 크면서 가장 근접한 key인 노드 3을 노드2를 지우고 그 자리에 넣습니다.

![BSTERASE](https://mblogthumb-phinf.pstatic.net/20160817_210/kks227_1471364090473GpbSX_PNG/6.png?type=w2)
![BSTERASE](https://mblogthumb-phinf.pstatic.net/20160817_141/kks227_147136409061479dRb_PNG/7.png?type=w2)
